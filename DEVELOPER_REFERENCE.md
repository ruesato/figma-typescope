# Developer Reference: Vite Migration Issues & Solutions

This document chronicles the technical challenges encountered during the migration from `@create-figma-plugin` to Vite + vanilla Figma Plugin API, and the solutions that ultimately resolved them.

## Migration Context

**Goal**: Migrate from `@create-figma-plugin` toolkit to a standard Vite + vanilla Figma Plugin API setup to:

- Use actual React instead of Preact compatibility layer
- Gain more control over the build process
- Simplify tooling for better maintainability
- Enable flexibility for complex features

**Approach**: Custom Vite configuration with a dual-context build:

- **Main context** (`src/main/code.ts`): Runs in Figma's sandbox
- **UI context** (`src/ui/`): Runs in an iframe with React

---

## Issue 1: Raw JavaScript Displayed (First Occurrence)

### Symptom

Plugin window showed raw minified JavaScript code instead of the rendered React UI.

### Root Cause

The HTML file generated by Vite referenced external files using absolute paths:

```html
<script type="module" crossorigin src="/ui.js"></script>
<link rel="stylesheet" crossorigin href="/ui.css" />
```

These absolute paths (`/ui.js`, `/ui.css`) don't work in Figma's iframe context, which doesn't have access to a file system or web server.

### Solution Attempt

Modified `vite-plugin-figma.ts` to inline CSS and JS into the HTML using string replacement:

```typescript
uiHtml = uiHtml
  .replace(
    /<script type="module" crossorigin src="\/ui\.js"><\/script>/,
    `<script type="module">${uiJs}</script>`
  )
  .replace(/<link rel="stylesheet" crossorigin href="\/ui\.css">/, `<style>${uiCss}</style>`);
```

### Outcome

Build completed, but the issue persisted. This was not the final solution (see Issue 5 for the real fix).

---

## Issue 2: ES2020 Syntax Not Supported

### Symptom

Figma console showed syntax errors:

```
Syntax error on line 89: Unexpected token ?
    a: solidFill.opacity ?? 1
                          ^
```

### Root Cause

Figma's JavaScript engine (likely V8 from an older Chrome version) doesn't support ES2020+ features like:

- Nullish coalescing operator (`??`)
- Optional chaining (`?.`)
- Other modern JavaScript syntax

Vite was defaulting to a modern target, outputting code that Figma couldn't execute.

### Solution

Updated `vite.config.ts` to transpile to ES2017:

```typescript
export default defineConfig({
  // ...
  build: {
    target: 'es2017', // ES2017 is compatible with Figma
    // ...
  },
});
```

**vite.config.ts:22**

### Outcome

✅ **Success** - Build succeeded with properly transpiled code. All modern syntax was converted to ES2017-compatible equivalents.

---

## Issue 3: Blank Plugin Modal

### Symptom

- Plugin modal loaded with correct title bar: "Figma Font Audit Pro (Developer VM)"
- Content area was completely blank (white screen)
- No errors in console

### Root Cause

Even though we attempted to inline assets in Issue 1, the inlining wasn't actually working. The HTML still had external references that couldn't resolve, so React never mounted.

### Solution

Enhanced `vite-plugin-figma.ts` to properly read and inline both CSS and JavaScript:

```typescript
// Read the generated files
let uiHtml = readFileSync(uiHtmlPath, 'utf-8');
const uiJs = readFileSync(uiJsPath, 'utf-8');
const uiCss = readFileSync(uiCssPath, 'utf-8');

// Inline the CSS and JS into the HTML
uiHtml = uiHtml
  .replace(
    /<script type="module" crossorigin src="\/ui\.js"><\/script>/,
    `<script>${uiJs}</script>`
  )
  .replace(/<link rel="stylesheet" crossorigin href="\/ui\.css">/, `<style>${uiCss}</style>`);
```

**vite-plugin-figma.ts:24-40** (original implementation)

### Outcome

Build succeeded (260kB main.js), but testing revealed raw JavaScript was still appearing (see Issue 4).

---

## Issue 4: Type Module Execution Issue

### Symptom

After inlining assets, the plugin UI showed raw JavaScript code fragments like:

```javascript
/") + "/"), R$1(c, b, e, "", function(a2) { return a2; })) : null != c && (O$1(c) && ...
```

### Hypothesis

The `type="module"` attribute on inlined `<script>` tags might not execute properly in Figma's iframe context. ES modules have different scoping rules and might be sandboxed differently.

### Solution Attempt

Removed `type="module"` from the inlined script tag:

```typescript
.replace(
  /<script type="module" crossorigin src="\/ui\.js"><\/script>/,
  `<script>${uiJs}</script>` // No type="module"
)
```

### Outcome

Build completed but issue persisted. This was a symptom of the deeper Issue 5.

---

## Issue 5: String Replacement Corruption ⚠️ CRITICAL

### Symptom

Raw JavaScript fragments continued to display in the UI even after all previous fixes.

### Root Cause Discovery

Examined the generated `build/main.js` and found that our regex replacement patterns were matching **inside the inlined JavaScript code itself**, not just in the HTML structure.

For example, React's internal code contained string literals like:

```javascript
e = a.replace(P$1, '<script type="module" crossorigin src="/ui.js"></script>/');
```

When we ran our string replacement on the already-inlined HTML, it was also replacing these strings **within the JavaScript code**, corrupting the React bundle.

**Example of corruption found in build/main.js:**

```javascript
// This React code got corrupted:
h += R$1(k2, b, e, f2, c);
// Because our replacement pattern matched a string inside it
```

### Solution: Direct HTML Generation

Instead of reading Vite's generated HTML and performing string replacements, we now **build the HTML template directly** with inlined assets:

```typescript
// Build the HTML with inlined assets directly
// This avoids string replacement issues where replacement patterns
// might match inside the JavaScript code itself
const uiHtml = `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Figma Font Audit Pro</title>
    <style>${uiCss}</style>
  </head>
  <body>
    <div id="root"></div>
    <script>${uiJs}</script>
  </body>
</html>`;
```

**vite-plugin-figma.ts:30-42**

### Outcome

✅ **SUCCESS** - Plugin UI rendered correctly! No more corruption, no more raw JavaScript display.

**Why this works:**

- We control the exact HTML structure
- No regex patterns that could accidentally match JavaScript code
- CSS and JS are cleanly inserted into their designated spots
- The JavaScript code remains untouched and uncorrupted

---

## Issue 6: Empty Text Node Errors

### Symptom

After running the audit, console showed multiple errors:

```
Error processing node 3:7793: Error: in getRangeFontName: Range outside of available characters.
'start' must be less than node.characters.length and 'end' must be less than or equal to node.characters.length
```

Additional error:

```
Error comparing style properties: TypeError: Cannot read properties of undefined (reading 'find')
```

### Root Cause

Two separate but related issues:

1. **Font Metadata Extraction**: The code tried to extract font properties from text nodes with 0 characters using `getRangeFontName(0, 1)`, which failed because there's no character at position 0.

2. **Style Comparison**: The `style.fills` property could be `undefined`, but the code called `.find()` on it without checking, causing a TypeError.

Empty text nodes are common in Figma designs:

- Placeholder text layers
- Deleted text content
- Component instances with empty overrides
- Hidden or conditional text elements

### Solution

**Fix 1: Skip empty nodes before processing** (`src/main/code.ts:113-116`):

```typescript
const node = textNodes[i];

// Skip empty text nodes silently
if (node.characters.length === 0) {
  continue;
}
```

**Fix 2: Add validation in extractFontMetadata** (`src/main/utils/fontMetadata.ts:31-33`):

```typescript
// Check if node has any characters
if (node.characters.length === 0) {
  throw new Error('Text node is empty - cannot extract font metadata');
}
```

**Fix 3: Add validation in compareStyleProperties** (`src/main/utils/styleDetection.ts:117-119`):

```typescript
// Check if node has any characters
if (node.characters.length === 0) {
  return matches; // Return all false for empty nodes
}
```

**Fix 4: Handle undefined fills array** (`src/main/utils/styleDetection.ts:133`):

```typescript
const styleFills = style.fills as readonly Paint[] | undefined;
```

**Fix 5: Check before comparison** (`src/main/utils/styleDetection.ts:159`):

```typescript
if (styleFills && compareFills(nodeFills, styleFills)) {
  matches.color = true;
}
```

**Fix 6: Validate arrays in compareFills** (`src/main/utils/styleDetection.ts:210-212`):

```typescript
// Ensure both arrays exist and are valid
if (!a || !Array.isArray(a) || !b || !Array.isArray(b)) {
  return false;
}
```

### Outcome

✅ **SUCCESS** - Empty text nodes are now silently skipped without errors. The audit continues processing valid nodes and completes successfully.

**Best Practice**: Always validate that text nodes have content before attempting to read character-level properties like font, size, or color.

---

## Issue 7: Message Handler Not Receiving Events

### Symptom

After clicking "Run Audit on Current Page", the UI showed no results. Console displayed repeated errors:

```
Unknown message type: undefined
```

The audit was running successfully in the main context (no errors), but the UI wasn't receiving the progress updates or results.

### Root Cause

Figma's plugin API wraps all messages sent via `figma.ui.postMessage()` in a `pluginMessage` property. The UI message handler was trying to access `event.data` directly, but should have been accessing `event.data.pluginMessage`.

**What was happening:**

```typescript
// Main context sends:
figma.ui.postMessage({ type: 'AUDIT_COMPLETE', result: {...} });

// Figma wraps it:
// event.data = { pluginMessage: { type: 'AUDIT_COMPLETE', result: {...} } }

// UI was trying to access:
const msg = event.data; // { pluginMessage: {...} }
msg.type // undefined! ❌

// Should have been:
const msg = event.data.pluginMessage; // { type: 'AUDIT_COMPLETE', ... }
msg.type // 'AUDIT_COMPLETE' ✅
```

### Solution

Updated the message handler to correctly access the wrapped message (`src/ui/hooks/useMessageHandler.ts:14-20`):

```typescript
const handleMessage = (event: MessageEvent) => {
  // Figma wraps plugin messages in event.data.pluginMessage
  const msg = event.data.pluginMessage as MainToUIMessage;

  // Ignore non-plugin messages
  if (!msg || !msg.type) {
    return;
  }

  switch (
    msg.type
    // ... handle different message types
  ) {
  }
};
```

### Outcome

✅ **SUCCESS** - The UI now correctly receives messages from the main context. Audit progress updates display in real-time, and results render properly after completion.

**Critical Note**: This is a fundamental requirement for Figma plugin communication. Without this fix, the UI and main contexts cannot communicate, making the plugin non-functional.

---

## Key Learnings

### 1. String Replacements on Self-Referential Content Are Dangerous

When your replacement patterns can appear in the content you're replacing (e.g., HTML tags appearing as strings in JavaScript), you risk corrupting your data. **Avoid regex replacements on code bundles.**

### 2. Figma Plugin Environment Constraints

- **No external file loading**: All assets must be inlined
- **Older JavaScript engine**: Target ES2017 or earlier
- **No ES modules in iframe**: Standard script tags work better than `type="module"`
- **Specific iframe context**: Absolute paths don't resolve

### 3. Build Process Best Practices

- **Read generated files sparingly**: Only read what you need to inline
- **Generate structured content**: Build templates directly rather than manipulating generated output
- **Verify bundle integrity**: Check that your build process doesn't corrupt code
- **Test incrementally**: Each fix should be tested before adding more complexity

### 4. Vite Plugin Development

- Use `writeBundle` hook to post-process build output
- Be cautious with string manipulation of bundled code
- Consider using template literals for HTML generation
- Always add comments explaining why you're doing something unusual

### 5. Data Validation is Critical

- **Always validate Figma node properties** before accessing them
- Empty text nodes are common and should be handled gracefully
- Check that arrays exist before calling array methods like `.find()`
- Properties like `fills` can be undefined even on valid style objects
- Fail gracefully: skip invalid nodes rather than crashing the entire audit

### 6. Figma's Message Passing API

- **Messages are wrapped**: Access `event.data.pluginMessage`, not `event.data`
- **Always validate messages**: Check that `msg` and `msg.type` exist before processing
- **Ignore non-plugin messages**: The iframe receives many browser events
- **Test communication early**: This is fundamental to plugin functionality
- Messages from main to UI: `figma.ui.postMessage(msg)` → `event.data.pluginMessage`
- Messages from UI to main: `parent.postMessage({ pluginMessage: msg }, '*')`

### 7. State Machine Design for Async Operations

- **Initialize state before sending progress**: Send an explicit state-setting message first (e.g., `STYLE_AUDIT_STARTED`)
- **Make transitions idempotent**: Allow `transitionTo(sameState)` to succeed silently rather than erroring
- **Batch progress messages**: Group updates to reduce message volume
- **Handle race conditions gracefully**: Design for the possibility of duplicate/out-of-order messages
- **Avoid strict validation in async contexts**: Race conditions are inevitable with message passing

### 8. Processing Large Datasets in Figma Plugins

- **Batch processing with yields**: Process data in batches and yield to the event loop between batches
- **Avoid synchronous loops with async calls**: The main thread will block
- **Use Promise.all() within batches**: Parallelism within batches is fast and safe
- **Check cancellation between batches**: Allow users to cancel long-running operations responsively
- **Monitor requestAnimationFrame violations**: These indicate main thread blocking

### 9. Figma Plugin API Limitations

- **No AbortController**: Use callback-based cancellation instead
- **No Promise.any()**: Use `Promise.all()` or `Promise.race()` instead
- **Limited API support**: The Figma sandbox is more restricted than standard browsers
- **Check before using modern APIs**: Always verify APIs work in Figma's sandbox
- **Have fallback patterns ready**: Simple callbacks, flags, and promises work everywhere

---

## Build Configuration Reference

### Final Working Configuration

**vite.config.ts:**

```typescript
export default defineConfig({
  plugins: [react(), figmaPlugin()],

  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },

  build: {
    outDir: 'build',
    emptyOutDir: true,
    minify: false, // Easier debugging during development
    target: 'es2017', // Figma compatibility

    rollupOptions: {
      input: {
        main: path.resolve(__dirname, 'src/main/code.ts'),
        ui: path.resolve(__dirname, 'src/ui/index.html'),
      },
      output: {
        entryFileNames: '[name].js',
        chunkFileNames: '[name].js',
        assetFileNames: '[name].[ext]',
      },
    },
  },
});
```

**vite-plugin-figma.ts:**

```typescript
export function figmaPlugin(): Plugin {
  return {
    name: 'vite-plugin-figma',

    writeBundle(options, bundle) {
      const outputDir = options.dir || 'build';
      const mainJsPath = resolve(outputDir, 'main.js');
      const uiJsPath = resolve(outputDir, 'ui.js');
      const uiCssPath = resolve(outputDir, 'ui.css');

      try {
        // Read the generated UI assets
        const uiJs = readFileSync(uiJsPath, 'utf-8');
        const uiCss = readFileSync(uiCssPath, 'utf-8');

        // Build HTML directly (no string replacement!)
        const uiHtml = `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Figma Font Audit Pro</title>
    <style>${uiCss}</style>
  </head>
  <body>
    <div id="root"></div>
    <script>${uiJs}</script>
  </body>
</html>`;

        // Inject into main.js
        let mainJs = readFileSync(mainJsPath, 'utf-8');
        const htmlInjection = `const __html__ = ${JSON.stringify(uiHtml)};\n`;
        mainJs = htmlInjection + mainJs;

        // Write modified main.js
        const fs = require('fs');
        fs.writeFileSync(mainJsPath, mainJs);

        console.log('✓ Inlined UI assets and injected into main.js');
      } catch (error) {
        console.error('Failed to inject UI HTML:', error);
      }
    },
  };
}
```

**manifest.json:**

```json
{
  "api": "1.0.0",
  "editorType": ["figma"],
  "id": "figma-font-audit-pro",
  "name": "Figma Font Audit Pro",
  "main": "build/main.js"
}
```

**src/main/code.ts:**

```typescript
// The __html__ variable is injected at build time
// @ts-ignore
declare const __html__: string;

// Show the plugin UI
figma.showUI(__html__, {
  width: 400,
  height: 600,
});
```

---

## Build Output

**Successful build produces:**

- `build/main.js` - 11.98 kB (includes inlined HTML)
- `build/ui.js` - 239.82 kB (React app bundle)
- `build/ui.css` - 21.67 kB (Tailwind styles)

**Note:** `ui.js` and `ui.css` are standalone files that get inlined into the HTML, which is then injected into `main.js`. Only `main.js` is referenced by Figma.

---

## Testing Checklist

After any build configuration changes, verify:

- [ ] Plugin loads without errors in Figma
- [ ] UI renders React components (not raw JS)
- [ ] No syntax errors in Figma console
- [ ] Interactive elements work (buttons, clicks, navigation)
- [ ] State management works (audit runs, results display)
- [ ] Styles apply correctly (Tailwind CSS renders)
- [ ] Message passing works (main ↔ UI communication)
- [ ] Build completes without warnings (except deprecation notices)
- [ ] Empty text nodes are handled gracefully (no console errors)
- [ ] Audit completes successfully with pages containing empty text layers
- [ ] Progress updates display in real-time during audit
- [ ] Results display correctly after audit completion

---

## Common Pitfalls to Avoid

❌ **Don't** use regex replacements on bundled JavaScript code
✅ **Do** generate HTML templates directly

❌ **Don't** reference external files in Figma plugin HTML
✅ **Do** inline all CSS and JavaScript

❌ **Don't** use modern JavaScript features (ES2020+)
✅ **Do** target ES2017 in your build config

❌ **Don't** use `type="module"` in inlined scripts
✅ **Do** use standard script tags for inlined code

❌ **Don't** assume Figma's iframe works like a browser
✅ **Do** test in the actual Figma plugin environment

❌ **Don't** access text node properties without checking character length
✅ **Do** validate `node.characters.length > 0` before calling `getRangeFontName()`, etc.

❌ **Don't** assume style properties like `fills` are always defined
✅ **Do** check for undefined/null before calling array methods

❌ **Don't** access `event.data` directly for plugin messages
✅ **Do** access `event.data.pluginMessage` in the UI message handler

❌ **Don't** use AbortController or other modern Web APIs in Figma plugins
✅ **Do** use simple callbacks, flags, and standard promises

❌ **Don't** process large datasets in synchronous loops
✅ **Do** batch process and yield to the event loop between batches

❌ **Don't** rely on strict state machine validation in async contexts
✅ **Do** make state transitions idempotent to handle duplicates gracefully

❌ **Don't** assume state initialization before sending progress messages
✅ **Do** send explicit state-setting messages before progress updates

---

## Troubleshooting Guide

### Plugin shows raw JavaScript

**Cause:** Assets not properly inlined, or string replacement corruption
**Fix:** Verify `vite-plugin-figma.ts` is generating HTML directly (Issue 5)

### Syntax errors in Figma console

**Cause:** Modern JavaScript features not supported
**Fix:** Set `build.target: 'es2017'` in `vite.config.ts` (Issue 2)

### Blank white screen

**Cause:** React not mounting, assets not loading
**Fix:** Check that CSS and JS are properly inlined in HTML (Issue 3)

### Build fails or corrupted output

**Cause:** File paths incorrect, or plugin hook not running
**Fix:** Verify paths in `vite-plugin-figma.ts`, check console for errors

### UI doesn't update after code changes

**Cause:** Plugin not reloaded in Figma
**Fix:** In Figma: Plugins → Development → Figma Font Audit Pro → Reload

### Errors: "Range outside of available characters"

**Cause:** Trying to access font properties on empty text nodes
**Fix:** Check `node.characters.length > 0` before calling `getRangeFontName()` (Issue 6)

### Errors: "Cannot read properties of undefined (reading 'find')"

**Cause:** Style properties like `fills` are undefined
**Fix:** Validate arrays exist before calling `.find()` or other array methods (Issue 6)

### "Unknown message type: undefined"

**Cause:** Message handler accessing `event.data` instead of `event.data.pluginMessage`
**Fix:** Update message handler to access `event.data.pluginMessage` (Issue 7)

### Audit runs but UI shows no results

**Cause:** Messages not being received by UI due to incorrect message structure
**Fix:** Ensure UI listens to `event.data.pluginMessage` and ignores messages without a type (Issue 7)

### State machine shows "Invalid transition" errors

**Cause:** Duplicate state transition messages or race conditions in async message handling
**Fix:** Make `transitionTo()` handle no-op transitions gracefully (Issue 8)

### Plugin shows `requestAnimationFrame` violations during large audits

**Cause:** Synchronous processing of thousands of layers blocks the main thread
**Fix:** Batch process layers with `Promise.all()` and yield to event loop (Issue 9)

### AbortController is not a constructor error

**Cause:** Figma plugin environment doesn't support modern Web APIs like AbortController
**Fix:** Use simple callback-based cancellation instead of AbortController (Issue 10)

---

## Issue 8: State Machine Race Conditions

### Symptom

Console displayed repeated errors when running audits:

```
[AuditState] Invalid transition: validating → validating
[AuditState] Invalid transition: scanning → scanning
Failed to transition from idle to scanning
```

UI showed audit summary but with console errors indicating state transition failures.

### Root Cause

Three related issues in the state machine design:

1. **Missing initialization message**: The main context never sent `STYLE_AUDIT_STARTED` to initialize the UI's state to `validating`, so the UI remained in `idle` when receiving `scanning` messages.

2. **Race conditions in state transitions**: Multiple messages could arrive before the previous state was fully processed, causing attempts to transition to the same state twice.

3. **Strict state machine validation**: The `transitionTo()` function rejected all invalid transitions, but sometimes duplicate transitions were legitimate and should be silently ignored.

### Solution

**Fix 1: Send STYLE_AUDIT_STARTED message** (`src/main/audit/auditEngine.ts:73-77`):

```typescript
// Send AUDIT_STARTED message to UI so it knows we're beginning the audit
this.sendMessage({
  type: 'STYLE_AUDIT_STARTED',
  payload: { state: 'validating' },
});
```

This ensures the UI transitions from `idle` → `validating` before receiving any progress messages.

**Fix 2: Make transitionTo() idempotent** (`src/ui/hooks/useAuditState.ts:71-74`):

```typescript
transitionTo: (newState: AuditState): boolean => {
  // If already in target state, silently succeed (no-op)
  if (auditState === newState) {
    return true; // ✅ Return true instead of throwing error
  }

  const validNext = VALID_TRANSITIONS[auditState];
  if (!validNext.includes(newState)) {
    console.error(`[AuditState] Invalid transition: ${auditState} → ${newState}`);
    return false;
  }
  // ... rest of logic
};
```

This prevents errors when duplicate messages try to transition to the same state.

**Fix 3: Simplify message handler** (`src/ui/hooks/useMessageHandler.ts:55-82`):

```typescript
case 'STYLE_AUDIT_STARTED':
  auditState.transitionTo(msg.payload.state);  // No guards needed
  auditState.setProgress(0);
  break;

case 'STYLE_AUDIT_PROGRESS':
  if (msg.payload.state) {
    auditState.transitionTo(msg.payload.state);  // Safe - idempotent now
  }
  auditState.setProgress(msg.payload.progress, msg.payload.currentStep);
  break;
```

Remove defensive checks since `transitionTo()` now handles duplicates gracefully.

### Outcome

✅ **SUCCESS** - No more state transition errors. Audit completes smoothly with proper state progression.

**Key Insight**: Making state transitions idempotent (safe to call multiple times with same target) is more robust than trying to prevent duplicate calls at the message handler level. This handles race conditions gracefully.

---

## Issue 9: requestAnimationFrame Violations During Large Audits

### Symptom

Console showed performance warning:

```
[Violation] 'requestAnimationFrame' handler took 143ms
```

UI showed "Analyzing text layers..." and "100%" progress but the browser was visibly blocked.

### Root Cause

The audit processor was using a synchronous loop to process 3,867+ text layers:

```typescript
// ❌ BAD: Blocks main thread for each layer
for (let i = 0; i < textLayers.length; i++) {
  const textNode = await figma.getNodeByIdAsync(rawLayer.id);
  // Process...
}
```

Each iteration calls `figma.getNodeByIdAsync()` which is async, but the loop continues without yielding to the event loop. With thousands of layers, the main thread gets blocked for hundreds of milliseconds, violating browser performance standards.

### Solution

**Batch processing with event loop yields** (`src/main/audit/processor.ts:87-104`):

```typescript
const BATCH_SIZE = 100; // Process 100 layers at a time
for (let i = 0; i < textLayers.length; i += BATCH_SIZE) {
  // Check for cancellation
  if (isCancelled && isCancelled()) {
    throw new Error('Processing cancelled by user');
  }

  const batch = textLayers.slice(i, Math.min(i + BATCH_SIZE, textLayers.length));

  // Process batch in parallel
  const batchResults = await Promise.all(batch.map((layer) => processTextLayer(layer, styles)));

  output.layers.push(...batchResults);

  // Yield to the event loop to prevent blocking
  await new Promise((resolve) => setTimeout(resolve, 0));
}
```

**Benefits:**

- ✅ Processes 100 layers in parallel within each batch
- ✅ Yields to event loop between batches with `setTimeout(resolve, 0)`
- ✅ Prevents browser from detecting long-running tasks
- ✅ Maintains performance while processing large datasets
- ✅ Supports cancellation between batches

### Outcome

✅ **SUCCESS** - No more requestAnimationFrame violations. Large audits complete smoothly with proper progress reporting.

**Best Practice**: When processing large datasets with async operations, batch them and yield to the event loop between batches. This keeps the UI responsive while maintaining efficiency.

---

## Issue 10: AbortController Not Available in Figma

### Symptom

Console error when audit started:

```
TypeError: AbortController is not a constructor
    at AuditEngine.processScanResults (PLUGIN_29_SOURCE:873:29)
```

Audit failed immediately and never started processing.

### Root Cause

The processor was trying to use `AbortController` for cancellation:

```typescript
// ❌ BAD: AbortController not available in Figma sandbox
const abortController = new AbortController();
const processed = await processAuditData(
  { textLayers, totalPages, options },
  abortController.signal
);
```

The Figma plugin environment runs in a restricted sandbox with limited JavaScript API support. Modern Web APIs like `AbortController`, `Promise.any()`, and others are not available.

### Solution

**Use callback-based cancellation** (`src/main/audit/processor.ts:48-50`):

```typescript
export async function processAuditData(
  input: ProcessorInput,
  isCancelled?: () => boolean  // ✅ Simple callback instead of AbortSignal
): Promise<ProcessorOutput> {
```

**In auditEngine.ts** (`src/main/audit/auditEngine.ts:520-527`):

```typescript
const processed = await processAuditData(
  {
    textLayers,
    totalPages,
    options,
  },
  () => this.cancelled // ✅ Pass a callback that checks the flag
);
```

**In processor.ts** (`src/main/audit/processor.ts:91-92`):

```typescript
// Check for cancellation
if (isCancelled && isCancelled()) {
  throw new Error('Processing cancelled by user');
}
```

**Benefits:**

- ✅ Compatible with Figma's restricted JavaScript environment
- ✅ Uses simple boolean flag already managed by `AuditEngine`
- ✅ Lightweight and straightforward
- ✅ Can be checked between batches for responsive cancellation

### Outcome

✅ **SUCCESS** - Audit engine works without errors. Cancellation is properly supported through a simple callback mechanism.

**Key Lesson**: Always check Figma plugin API limitations. Modern browser APIs may not be available in the sandbox. Use simpler, more compatible patterns instead.

---

## Migration Success Metrics

✅ **Removed dependencies:**

- `@create-figma-plugin/build`
- `@create-figma/plugin-typings` (replaced with `@figma/plugin-typings`)
- `preact` and `preact/compat`

✅ **Added dependencies:**

- `react` and `react-dom` (actual React)
- `vite` and `@vitejs/plugin-react`
- Custom `vite-plugin-figma.ts`

✅ **Achieved goals:**

- Using real React 18 with createRoot API
- Full control over build process
- Simpler, more maintainable tooling
- Flexibility for future enhancements

---

## References

- [Figma Plugin API](https://www.figma.com/plugin-docs/)
- [Vite Documentation](https://vitejs.dev/)
- [Vite Plugin Development](https://vitejs.dev/guide/api-plugin.html)
- [ES2017 Specification](https://www.ecma-international.org/ecma-262/8.0/)

---

**Document Version:** 1.2
**Last Updated:** 2025-11-22
**Author:** Claude Code (with Ryan Uesato)

## Changelog

### Version 1.2 (2025-11-22)

- Added **Issue 8: State Machine Race Conditions** - fixing duplicate state transitions
- Added **Issue 9: requestAnimationFrame Violations** - batch processing with event loop yields
- Added **Issue 10: AbortController Not Available** - callback-based cancellation instead
- Added Key Learning #7: State Machine Design for Async Operations
- Added Key Learning #8: Processing Large Datasets in Figma Plugins
- Added Key Learning #9: Figma Plugin API Limitations
- Enhanced Troubleshooting Guide with 3 new entries for audit-specific issues
- Added 5 new items to Common Pitfalls for async/performance patterns
- Added detailed explanations of audit engine architecture and state flow

### Version 1.1 (2025-11-20)

- Added **Issue 6: Empty Text Node Errors** - handling nodes with 0 characters
- Added **Issue 7: Message Handler Not Receiving Events** - Figma's message wrapping
- Updated Key Learnings with data validation and message passing best practices
- Enhanced Troubleshooting Guide with 4 new entries
- Added 3 new items to Common Pitfalls
- Expanded Testing Checklist with validation checks

### Version 1.0 (2025-11-19)

- Initial documentation of migration from @create-figma-plugin to Vite
- Documented Issues 1-5: Build configuration and asset inlining challenges
- Complete build configuration reference
- Key learnings and best practices
